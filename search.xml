<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于持续集成</title>
      <link href="/2022/04/24/guan-yu-chi-xu-ji-cheng/"/>
      <url>/2022/04/24/guan-yu-chi-xu-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><h3 id="CI-的含义"><a href="#CI-的含义" class="headerlink" title="CI 的含义"></a>CI 的含义</h3><p>CI 的意思是 <strong>持续构建</strong>。</p><p>负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 <strong>制品</strong> ，并将制品推送至到制品库里面。常用工具有 Gitlab CI，Github CI，Jenkins 等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为 <strong>制品</strong>，保存制品的地方被称为 <strong>制品库</strong>。</p><h3 id="CD-的含义"><a href="#CD-的含义" class="headerlink" title="CD 的含义"></a>CD 的含义</h3><p>CD 则有 2 层含义：<strong>持续部署</strong>(Continuous Deployment) 和 <strong>持续交付</strong>(Continuous Delivery) 。</p><p><strong>持续交付</strong> 的概念是：将制品库的制品拿出后，部署在测试环境 / 交付给客户提前测试。<strong>持续部署</strong> 则是将制品部署在生产环境</p><p><strong>简而言之：持续集成就是能够采用自动化的手段，解放人的双手，实现项目持续交付的过程。</strong></p><p>详情见 <a href="https://help.coding.intlgame.com/docs/ci/intro.html">持续集成介绍</a></p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>在 coding 平台中实现持续集成的方式，</p><ul><li>打开项目找到需要的仓库，左侧导航中有一栏持续集成。</li></ul><p><img src="/api/project/1077/files/992654/imagePreview" alt="持续集成导航"></p><ul><li>选择点击构建计划，右上角新建构建计划，可以选择模板或者自定义的构建过程(这里我选择自定义构建)，如下图二，选择构建的代码仓库,配置来源中，hover 问号，查看来源区别(tips:静态配置在 coding 平台中编写构建文件)</li></ul><p><img src="/api/project/1077/files/992655/imagePreview" alt="创建构建计划"></p><p><img src="/api/project/1077/files/992657/imagePreview" alt="图二"></p><ul><li><p>配置构建过程</p></li><li><p>新的构建计划中，播放按钮为开始构建，三点符为配置构建过程，点击计划名称可以查看每一次构建状态的详情</p></li></ul><p><img src="/api/project/1077/files/992658/imagePreview" alt="图片"></p><ul><li>点击三点符的设置，配置计划明细</li></ul><p><img src="/api/project/1077/files/992660/imagePreview" alt="图片"></p><ul><li>基础信息配置中，自定义的构建节点需要腾讯侧申请构建机，并安装基础环境(自定义的构建节点可在持续集成下的构建节点查看详情)，默认 coding 会提供一台已安装好环境的云服务器</li></ul><p><img src="/api/project/1077/files/992661/imagePreview" alt="图片"></p><ul><li><p>流程配置为 Jenkins 规则的编写,即整个持续集成的重点,底部为 umijs 前端项目自动化部署到自定义构建节点的例子</p></li><li><p>触发规则配置 JenkinsFile 文件的触发方式</p></li></ul><p><img src="/api/project/1077/files/992662/imagePreview" alt="图片"></p><ul><li>变量与缓存介绍详见 <a href="https://help.coding.intlgame.com/docs/ci/env.html">环境变量</a></li></ul><blockquote><p>umijs 自动化部署示例</p></blockquote><pre><code>pipeline {agent anystages {stage('Checkout') {steps {checkout([$class: 'GitSCM',branches: [[name: GIT_BUILD_REF]],userRemoteConfigs: [[url: GIT_REPO_URL,credentialsId: CREDENTIALS_ID]]])}}stage("Judge") {steps {//echo '${CREDENTIALS_ID}'//sh 步骤执行 shell 命令，只有命令返回的状态码为零时才会继续。任何非零的返回码都将使流水线失败。sh '''ls -almkdir /var/nm_cachemkdir "${CACHE_DIR}"cache_dir="${CACHE_DIR}"cache_nm="${CACHE_DIR}node_modules"cache_lock="${CACHE_DIR}yarn.lock"if [ ! -d "$cache_dir" ]; then mkdir ${cache_dir}; fiif [ ! -d "$cache_nm" ]; then mkdir ${cache_nm}; fiif [ -d "$cache_nm" ]; then ln -sf ${cache_nm} ./; fiif [ -f "$cache_lock" ]; then mv -n ${cache_lock} .; fils -al'''}}stage('Build') {steps {sh '''npm config set registry https://registry.npm.taobao.orgyarn installyarn buildtar -cvf dist.tar distls -almv ./yarn.lock ${CACHE_DIR}rm -rf ./node_modulesls -al'''//命令存档文件(捕获符合模式,匹配的交付件并将其保存到 Jenkins master 节点以供后续获取。)//fingerprint:记录文件的指纹以跟踪使用情况archiveArtifacts artifacts: 'dist.tar', fingerprint: true}}stage('Deploy') {steps {//将归档的文件复制到工作区unarchive mapping: ['dist.tar': 'dist.tar']echo '--- Deploy ---'//ssh-agent 代理sshagent(["${CREDENTIALS_ID}"]) {//scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令sh 'scp -o StrictHostKeyChecking=no dist.tar root@${SERVER_IP_1}:${SERVER_DEPLOY_DIR}'sh 'ssh -o StrictHostKeyChecking=no root@${SERVER_IP_1} \"rm -rf ${SERVER_DEPLOY_DIR}dist; tar -xvf ${SERVER_DEPLOY_DIR}dist.tar -C ${SERVER_DEPLOY_DIR}\"'}}}environment {SERVER_IP_1 = "11.22.33.44"SERVER_DEPLOY_DIR = "/www/wwwroot/"//缓存目录CACHE_DIR = "/var/nm_cache/mtool-demo/"}}</code></pre><pre><code>整个部署脚本分为四个步骤- Checkout（在指定 git 仓库通过指定证书文件获取代码）- Judge（对node_modules和yarn.lock的缓存）- 看指定 node_modules 缓存文件夹是否存在，不存在则新建该文件夹；- 看缓存文件夹中是否有 node_modules 文件夹，如果没有则新建该文件夹；并且将该文件夹软连接到当前目录；- 看缓存文件夹中是否有 yarn.lock 文件，如果有则移动到当前文件夹；- Build（通过指定命令进行编译，将编译后的产物存档）- 移除 node_modules 文件夹的软连接；- 将 yarn.lock 文件移动到缓存文件夹中；- Deploy（通过指定命令部署）注意：Deploy报错 `No such DSL method 'sshagent' found among steps`，只需要安装 `SSH Agent Jenkins plugin`即可</code></pre><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="Jenkins-是什么？"><a href="#Jenkins-是什么？" class="headerlink" title="Jenkins 是什么？"></a>Jenkins 是什么？</h3><p>Jenkins 可以理解为一个 java 项目，目标为提供一个面向软件持续集成的软件平台,事实上 Jenkins 是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序,官网<a href="https://www.jenkins.io/">Jenkins</a></p><h3 id="Jenkins-基础"><a href="#Jenkins-基础" class="headerlink" title="Jenkins 基础"></a>Jenkins 基础</h3><p>Jenkinsfile 支持<code>声明式</code>（Declarative）和<code>脚本式</code>（Script）两种语法(因为声明式（Declarative）语法是 Jenkins 更新支持的特性，所以本篇主要聚焦于声明式文件的语法规则)，声明式和脚本化的流水线从根本上是不同的。 声明式流水线的是 Jenkins 流水线更近的特性:</p><ul><li><p>相比脚本化的流水线语法，它提供更丰富的语法特性,</p></li><li><p>是为了使编写和读取流水线代码更容易而设计的。</p></li></ul><h4 id="Jenkins-Pipeline-流水线-基础"><a href="#Jenkins-Pipeline-流水线-基础" class="headerlink" title="Jenkins Pipeline(流水线)基础"></a>Jenkins Pipeline(流水线)基础</h4><ul><li><p>Jenkins Pipeline（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。</p></li><li><p>持续交付 Pipeline 自动化的表达了这样一种流程：将基于版本控制管理的软件持续的交付到您的用户和消费者手中。</p></li><li><p>Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 Jenkinsfile ）中，该文件可以被放入项目的源代码控制库中。</p></li></ul><blockquote><p>nodejs 示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent { docker 'node:6.3' }stages {stage('build') {steps {sh 'npm --version'}}}}</code></pre><h5 id="Agent（执行环境或称为代理）"><a href="#Agent（执行环境或称为代理）" class="headerlink" title="Agent（执行环境或称为代理）"></a>Agent（执行环境或称为代理）</h5><p>执行环境描述了整个流水线执行过程或者某个阶段的执行环境，必须出现在描述文件顶级或者每一个阶段里(必填参数，且必须出现在描述文件顶级或者每一个阶段里)。</p><p>参数：</p><ul><li><p>any 在任何可用的代理上执行流水线或阶段。例如: agent any</p></li><li><p>none 当在 pipeline 块的顶部没有全局代理， 该参数将会被分配到整个流水线的运行中并且每个 stage 部分都需要包含他自己的 agent 部分。比如: agent none</p></li><li><p>none 当在 pipeline 块的顶部没有全局代理， 该参数将会被分配到整个流水线的运行中并且每个 stage 部分都需要包含他自己的 agent 部分。比如: agent none</p></li><li><p>node agent { node { label ‘labelName’ } } 和 agent { label ‘labelName’ } 一样, 但是 node 允许额外的选项 (比如 customWorkspace )</p></li><li><p>docker 使用给定的容器执行流水线或阶段。该容器将在预置的 node 上，或在匹配可选定义的<code>label</code> 参数上，动态的供应来接受基于 Docker 的流水线。docker 也可以选择的接受 args 参数，该参数可能包含直接传递到 docker run 调用的参数, 以及 alwaysPull 选项, 该选项强制 docker pull ，即使镜像名称已经存在。</p></li></ul><p>-dockerfile 执行流水线或阶段, 使用从源代码库包含的 Dockerfile 构建的容器。</p><h5 id="Stages-阶段列表"><a href="#Stages-阶段列表" class="headerlink" title="Stages(阶段列表)"></a>Stages(阶段列表)</h5><p>阶段列表包含了一系列的阶段，一个阶段列表最少包含一个阶段。流水线里必须要有且仅有一个阶段列表(必填参数，且在 流水线（pipeline）内只能出现一次)</p><h5 id="Stage-阶段"><a href="#Stage-阶段" class="headerlink" title="Stage(阶段)"></a>Stage(阶段)</h5><p>一个阶段定义了一系列紧密相关的步骤。每个阶段在整条流水线中各自承担了独立、明确的责任。比如“构建阶段”、“测试阶段”或“部署阶段”。通常来讲，所有的实际构建过程都放置在阶段里面(必填参数,至少一个)。</p><h5 id="Steps-步骤列表"><a href="#Steps-步骤列表" class="headerlink" title="Steps(步骤列表)"></a>Steps(步骤列表)</h5><p>步骤列表描述了一个阶段内具体要做什么事，具体要执行什么命令。比如有一个步骤（step）需要系统打印一条“构建中…”的消息，即执行命令 echo ‘构建中…’(必填参数，且在每一个 阶段（stage）块内)。</p><h5 id="post-强大的故障处理"><a href="#post-强大的故障处理" class="headerlink" title="post(强大的故障处理)"></a>post(强大的故障处理)</h5><p>post 部分定义一个或多个 steps ，这些阶段根据流水线或阶段的完成情况而 运行(取决于流水线中 post 部分的位置). post 支持以下 post-condition 块中的其中之一: always, changed, failure, success, unstable, 和 aborted。这些条件块允许在 post 部分的步骤的执行取决于流水线或阶段的完成状态(按照惯例, post 部分应该放在流水线的底部)。</p><ul><li><p>always 无论流水线或阶段的完成状态如何，都允许在 post 部分运行该步骤。</p></li><li><p>changed 只有当前流水线或阶段的完成状态与它之前的运行不同时，才允许在 post 部分运行该步骤。</p></li><li><p>failure 只有当前流水线或阶段的完成状态为”failure”，才允许在 post 部分运行该步骤, 通常 web UI 是红色。</p></li><li><p>success 只有当前流水线或阶段的完成状态为”success”，才允许在 post 部分运行该步骤, 通常 web UI 是蓝色或绿色。</p></li><li><p>unstable 只有当前流水线或阶段的完成状态为”unstable”，才允许在 post 部分运行该步骤, 通常由于测试失败,代码违规等造成。通常 web UI 是黄色。</p></li><li><p>aborted 只有当前流水线或阶段的完成状态为”aborted”，才允许在 post 部分运行该步骤, 通常由于流水线被手动的 aborted。通常 web UI 是灰色。</p></li></ul><h5 id="Parallel-并行"><a href="#Parallel-并行" class="headerlink" title="Parallel(并行)"></a>Parallel(并行)</h5><p>并行用来声明一些并行执行的阶段，通常适用于阶段与阶段之间不存在依赖关系的情况下，用来加快执行速度。注意任何含并行区块下的阶段不能再设置执行环境。</p><h5 id="Script-脚本"><a href="#Script-脚本" class="headerlink" title="Script(脚本)"></a>Script(脚本)</h5><p>执行一段脚本作为一个步骤。一般不用，有时需要“应急出口”才派上用场</p><blockquote><p>流水线示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anystages {stage('Build') {steps {sh 'make'}}stage('Test'){steps {sh 'make check'junit 'reports/**/*.xml'}}stage('Deploy') {steps {sh 'make publish'}}}}</code></pre><blockquote><p>tips：pipeline 规则见<a href="https://www.jenkins.io/zh/doc/book/pipeline/syntax/">规则</a></p></blockquote><h3 id="Jenkins-环境变量"><a href="#Jenkins-环境变量" class="headerlink" title="Jenkins 环境变量"></a>Jenkins 环境变量</h3><h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h4><p>Jenkins 流水线通过全局变量 env 提供环境变量，它在 Jenkinsfile 文件的任何地方都可以使用。Jenkins 流水线中可访问的完整的环境变量列表记录在 <code>${YOUR_JENKINS_URL}/pipeline-syntax/globals#env</code>，并且包括：</p><ul><li><p>BUILD_ID 当前构建的 ID，与 Jenkins 版本 1.597+ 中创建的构建号 BUILD_NUMBER 是完全相同的。</p></li><li><p>BUILD_NUMBER 当前构建号，比如 “153”。</p></li><li><p>BUILD_TAG 字符串 <code>jenkins-${JOB_NAME}-${BUILD_NUMBER}</code>。可以放到源代码、jar 等文件中便于识别。</p></li><li><p>BUILD_URL 可以定位此次构建结果的 URL（比如 <a href="http://buildserver/jenkins/job/MyJobName/17/">http://buildserver/jenkins/job/MyJobName/17/</a> ）</p></li><li><p>EXECUTOR_NUMBER 用于识别执行当前构建的执行者的唯一编号（在同一台机器的所有执行者中）。这个就是你在“构建执行状态”中看到的编号，只不过编号从 0 开始，而不是 1。</p></li><li><p>JAVA_HOME 如果你的任务配置了使用特定的一个 JDK，那么这个变量就被设置为此 JDK 的 JAVA_HOME。当设置了此变量时，PATH 也将包括 JAVA_HOME 的 bin 子目录。</p></li><li><p>JENKINS_URL Jenkins 服务器的完整 URL，比如 <a href="https://example.com:port/jenkins/">https://example.com:port/jenkins/</a> （注意：只有在“系统设置”中设置了 Jenkins URL 才可用）。</p></li><li><p>JOB_NAME 本次构建的项目名称，如 “foo” 或 “foo/bar”。</p></li><li><p>NODE_NAME 运行本次构建的节点名称。对于 master 节点则为 “master”。</p></li><li><p>WORKSPACE workspace 的绝对路径。</p></li></ul><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anystages {stage('Example') {steps {echo "Running ${env.BUILD_ID} on ${env.JENKINS_URL}"}}}}</code></pre><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>优先级 withEnv &gt; environment</p><p>同样的，环境变量的作用域取决于定义的位置</p><h4 id="动态设置环境变量"><a href="#动态设置环境变量" class="headerlink" title="动态设置环境变量"></a>动态设置环境变量</h4><p>环境变量可以在运行时设置，然后给 shell 脚本（<code>sh</code>）、Windows 批处理脚本（<code>batch</code>）和 Powershell 脚本（<code>powershell</code>）使用。各种脚本都可以返回 <code>returnStatus</code> 或 <code>returnStdout</code>。</p><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anyenvironment {// 使用 returnStdoutCC = """${sh(returnStdout: true,script: 'echo "clang"')}"""// 使用 returnStatusEXIT_STATUS = """${sh(returnStatus: true,script: 'exit 1')}"""}stages {stage('Example') {environment {DEBUG_FLAGS = '-g'}steps {sh 'printenv'}}}}</code></pre><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p><code>options</code> 指令允许从流水线内部配置特定于流水线的选项。 流水线提供了许多这样的选项, 比如 <code>buildDiscarder</code>,但也可以由插件提供, 比如 `timestamps(同样可以配置在 stage 中)</p><ul><li><p>buildDiscarder 为最近的流水线运行的特定数量保存组件和控制台输出。例如: options { buildDiscarder(logRotator(numToKeepStr: ‘1’)) }</p></li><li><p>disableConcurrentBuilds 不允许同时执行流水线。 可被用来防止同时访问共享资源等。 例如: options { disableConcurrentBuilds() }</p></li><li><p>overrideIndexTriggers 允许覆盖分支索引触发器的默认处理。 如果分支索引触发器在多分支或组织标签中禁用, options { overrideIndexTriggers(true) } 将只允许它们用于促工作。否则, options { overrideIndexTriggers(false) } 只会禁用改作业的分支索引触发器。</p></li><li><p>skipDefaultCheckout 在<code>agent</code> 指令中，跳过从源代码控制中检出代码的默认情况。例如: options { skipDefaultCheckout() }</p></li><li><p>skipStagesAfterUnstable 一旦构建状态变得 UNSTABLE，跳过该阶段。例如: options { skipStagesAfterUnstable() }</p></li><li><p>checkoutToSubdirectory 在工作空间的子目录中自动地执行源代码控制检出。例如: options { checkoutToSubdirectory(‘foo’) }</p></li><li><p>timeout 设置流水线运行的超时时间, 在此之后，Jenkins 将中止流水线。例如: options { timeout(time: 1, unit: ‘HOURS’) }</p></li><li><p>retry 在失败时, 重新尝试整个流水线的指定次数。 For example: options { retry(3) }</p></li><li><p>timestamps 预谋此阶段生成的所有控制台输出以及该行发出的时间一致。例如: options { timestamps() }</p></li></ul><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anyoptions {timeout(time: 1, unit: 'HOURS')}stages {stage('Example') {steps {echo 'Hello World'}}}}</code></pre><h4 id="parameters-参数指令"><a href="#parameters-参数指令" class="headerlink" title="parameters(参数指令)"></a>parameters(参数指令)</h4><p>parameters 指令提供了一个用户在触发流水线时应该提供的参数列表。这些用户指定参数的值可通过 params 对象提供给流水线步骤(只能有一个且在 pipeline 下)。</p><ul><li><p>string 字符串类型的参数, 例如: parameters { string(name: ‘DEPLOY_ENV’, defaultValue: ‘staging’, description: ‘’) }</p></li><li><p>booleanParam 布尔参数, 例如: parameters { booleanParam(name: ‘DEBUG_BUILD’, defaultValue: true, description: ‘’)</p></li></ul><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anyparameters {string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')}stages {stage('Example') {steps {echo "Hello ${params.PERSON}"}}}}</code></pre><h4 id="triggers-触发器"><a href="#triggers-触发器" class="headerlink" title="triggers(触发器)"></a>triggers(触发器)</h4><p><code>triggers</code> 指令定义了流水线被重新触发的自动化方法</p><ul><li><p>cron 接收 cron 样式的字符串来定义要重新触发流水线的常规间隔 ,比如: triggers { cron(‘H _/4 _ * 1-5’) }</p></li><li><p>pollSCM 接收 cron 样式的字符串来定义一个固定的间隔，在这个间隔中，Jenkins 会检查新的源代码更新。如果存在更改, 流水线就会被重新触发。例如: triggers { pollSCM(‘H _/4 _ * 1-5’) }</p></li><li><p>upstream 接受逗号分隔的工作字符串和阈值。 当字符串中的任何作业以最小阈值结束时，流水线被重新触发。例如: triggers { upstream(upstreamProjects: ‘job1,job2’, threshold: hudson.model.Result.SUCCESS) }</p></li></ul><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anytriggers {cron('H */4 * * 1-5')}stages {stage('Example') {steps {echo 'Hello World'}}}}</code></pre><h4 id="tool-工具"><a href="#tool-工具" class="headerlink" title="tool(工具)"></a>tool(工具)</h4><p>定义自动安装和放置 PATH 的工具的一部分。如果 agent none 指定，则忽略该操作(Inside the pipeline block or a stage block)。</p><p>支持工具 maven jdk gradle</p><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anytools {maven 'apache-maven-3.0.1'}stages {stage('Example') {steps {sh 'mvn --version'}}}}</code></pre><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>stage 的 input 指令允许你使用 input step 提示输入。 在应用了 options 后，进入 stage 的 agent 或评估 when 条件前， stage 将暂停。 如果 input 被批准, stage 将会继续。 作为 input 提交的一部分的任何参数都将在环境中用于其他 stage。</p><ul><li><p>message 必需的。 这将在用户提交 input 时呈现给用户。</p></li><li><p>id input 的可选标识符， 默认为 stage 名称。</p></li><li><p>ok <code>input</code>表单上的”ok” 按钮的可选文本。</p></li><li><p>submitter 可选的以逗号分隔的用户列表或允许提交 input 的外部组名。默认允许任何用户。</p></li><li><p>submitterParameter 环境变量的可选名称。如果存在，用 submitter 名称设置。</p></li><li><p>parameters 提示提交者提供的一个可选的参数列表。 更多信息参见 [parameters]。</p></li></ul><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anystages {stage('Example') {input {message "Should we continue?"ok "Yes, we should."submitter "alice,bob"parameters {string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')}}steps {echo "Hello, ${PERSON}, nice to meet you."}}}}</code></pre><h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>when 指令允许流水线根据给定的条件决定是否应该执行阶段。 when 指令必须包含至少一个条件。 如果 when 指令包含多个条件, 所有的子条件必须返回 True，阶段才能执行。 这与子条件在 allOf 条件下嵌套的情况相同(在 stage 中编写)</p><ul><li><p>branch 当正在构建的分支与模式给定的分支匹配时，执行这个阶段, 例如: when { branch ‘master’ }。注意，这只适用于多分支流水线。</p></li><li><p>environment 当指定的环境变量是给定的值时，执行这个步骤, 例如: when { environment name: ‘DEPLOY_TO’, value: ‘production’ }</p></li><li><p>expression 当指定的 Groovy 表达式评估为 true 时，执行这个阶段, 例如: when { expression { return params.DEBUG_BUILD } }</p></li><li><p>not 当嵌套条件是错误时，执行这个阶段,必须包含一个条件，例如: when { not { branch ‘master’ } }</p></li><li><p>allOf 当所有的嵌套条件都正确时，执行这个阶段,必须包含至少一个条件，例如: when { allOf { branch ‘master’; environment name: ‘DEPLOY_TO’, value: ‘production’ } }</p></li><li><p>anyOf 当至少有一个嵌套条件为真时，执行这个阶段,必须包含至少一个条件，例如: when { anyOf { branch ‘master’; branch ‘staging’ } }</p></li></ul><p>在进入 stage 的 agent 前评估 when</p><p>默认情况下, 如果定义了某个阶段的代理，在进入该<code>stage</code> 的 agent 后该 stage 的 when 条件将会被评估。但是, 可以通过在 when 块中指定 beforeAgent 选项来更改此选项。 如果 beforeAgent 被设置为 true, 那么就会首先对 when 条件进行评估 , 并且只有在 when 条件验证为真时才会进入 agent 。</p><blockquote><p>示例</p></blockquote><pre><code>Jenkinsfile (Declarative Pipeline)pipeline {agent anystages {stage('Example Build') {steps {echo 'Hello World'}}stage('Example Deploy') {when {branch 'production'}steps {echo 'Deploying'}}}}</code></pre><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>上面创建构建计划的测试用例中有提到在 coding 中有两种方式来运行 Jenkins, 而创建一个检入到源码管理系统中 的 <code>Jenkinsfile</code> 带来了一些直接的好处：</p><ul><li><p>流水线上的代码评审/迭代</p></li><li><p>对流水线进行审计跟踪</p></li><li><p>流水线的单一可信数据源 ,能够被项目的多个成员查看和编辑。</p></li><li><p>关于 Jenkinsfile 的更多介绍见<a href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/">jenkinsfile</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/18/hello-world/"/>
      <url>/2022/04/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
